#!/usr/bin/env python3

# This script goes directly to the Gentoo mirror to fetch the stage3; it does NOT use the images found on Dockerhub. The reason is that we require a slighly different directory structure.
# Furthermore, our build system packs the stage3 tarball in its own root-dir instead of deleting it as does the upstream Dockerfile. This is so that we can pack it into a custom root when desired.
# These routinely get reclaimed so the disc usage isn't really much of a problem.
# Also, our build process is split into two Dockerfiles, found in includes/dockerfiles/gentoomuch-bootstrap: The first gets munged from step1, step2, and step3. The Second is recorded as step4.Dockerfile: It copies in the image created by the first and then created a few extra directories.

import sys, os, re
from include.gentoomuch_common import read_file_lines, write_file_lines, arch_config_path

# Support matrix
# TODO: Keep in central file, turn into proper documentation/error messages
#tags_to_arches = {
#    "latest": ["amd64","arm64","armv5tel","armv6j_hardfp","armv7a_hardfp","ppc64le","s390x","x86"]
#    ,"hardened": ["amd64","x86"]
#    ,"hardened+nomultilib": ["amd64"]
#    ,"musl-hardened": ["amd64"]
#    ,"musl-vanilla": ["amd64","x86"]
#    ,"nomultilib": ["amd64"]
#    ,"systemd": ["amd64","arm64","x86"]
#    ,"uclibc-hardened": ["amd64", "x86"]
#    ,"uclibc-vanilla": ["amd64","x86"]
#    }

# TODO: Just for kicks, learn how to make the following work.
#arches_to_tag = { v: k for k, v in tags_to_arches.items() }

# WE BEGIN HERE...
# Check if architecture file exists
arch = open(arch_config_path).read().strip()

# Handle arguments
is_default_tag = False  
custom_upstream = False
if len(sys.argv) > 1: # Or, do we use a custom upstream tag?
    tag = sys.argv[1].strip()
    if tag == 'default':
        is_default_tag = True
if len(sys.argv) > 2: # Do we have a custom upstream? This can save a great deal of time if you mirror these things to LAN/localhost when the internet connection isn't being used too much.
    custom_upstream = True
    upstream_url = sys.argv[2].strip()
if len(sys.argv) == 1 or len(sys.argv) > 3: # Too many or too few arguments.
    sys.exit('Usage: pull-stage3 <arch> [tag] [upstream root (upstream_url://*, ftp://*)]')
#TODO: Verify upstream support

# These paths are used for working with our Dockerfile configs.
dockerfile_input_path = 'include/dockerfiles/gentoomuch-bootstrap/'
dockerfile_output_path = 'work/bootstrap/'
# Bootstrap Phase:
# We can now append all the Dockerfiles for the bootstrap phase, using a different file given whether or not we use a custom tag.
lines = read_file_lines(os.path.join(dockerfile_input_path, 'step1.Dockerfile'))
if is_default_tag: # We don't have a custom tag.
    lines.extend(read_file_lines(os.path.join(dockerfile_input_path, 'step2.Dockerfile.archonly')))
else: # We do have a custom tag. Hurray!
    lines.extend(read_file_lines(os.path.join(dockerfile_input_path, 'step2.Dockerfile.fully-loaded')))
lines.extend(read_file_lines(os.path.join(dockerfile_input_path, 'step3.Dockerfile')))
print(lines)
# We create the output directory if it isn't present.
if not os.path.isdir(dockerfile_output_path):
    os.mkdir(dockerfile_output_path)
# Now we finally write the Dockerfile for the bootstrap image.
write_file_lines(os.path.join(dockerfile_output_path, 'Dockerfile'), lines)
# These two are for the error and debug messages'
attempt_msg_prefix = '[Gentoomuch.pull-stage3] Attempted to pull stage3 of arch "' 
tag_msg = '", wih tag "' 
# This is the image that gets used to build/pack by this tool.
# The only purpose of the bootstrap Docker image is to download, verify, and unpack the upstream stage3. Then it gets copied from and destroyed.
output_img_tag = 'default'
if not is_default_tag:
    output_img_tag = tag
    output_img_tag = re.sub(re.escape('+'), '-', tag)
else:
    output_img_tag = 'default'
# Names for images and stuff.
output_img_name = 'localhost:5000/gentoomuch-' + arch + '-upstream:' + output_img_tag
bootstrap_img_name = 'gentoomuch-bootstrap'
bootstrap_cmd_head = 'docker image rm ' + output_img_name + ' & docker image rm ' + bootstrap_img_name + ' & cd ' + dockerfile_output_path + ' && docker build '
bootstrap_cmd_tail = ' -t gentoomuch-bootstrap .'
# Now we set the command that gets run.
common_args = '--build-arg ARCH=' + arch + ' --build-arg MICROARCH=' + arch
#upstream_url_msg = " from custom upstream "
if not is_default_tag: # If we have a custom tag
    common_args = common_args + ' --build-arg SUFFIX=' + tag + ' '
    # print(attempt_msg_prefix + arch + tag_msg + tag + '" from gentoo\'s upstream')
if custom_upstream: # If our upstream isn't the one defined in the Dockerfile
    common_args = common_args + ' --build-arg DIST=' + upstream_url
# We build the bootstrap image.
code = os.system(bootstrap_cmd_head + common_args + bootstrap_cmd_tail)
if code != 0:
    sys.exit('[Gentoomuch.pull-stage3] Bootstrap Docker image build failed.')
# We then build the final output image (AKA: The value-added part we wrote this thing to do...)
code = os.system('cp ' + os.path.join(dockerfile_input_path,'step4.Dockerfile') + ' ' + os.path.join(dockerfile_output_path,  'Dockerfile') + ' && cd ' + dockerfile_output_path + ' && docker build -t ' + output_img_name + ' .')
if code != 0:
    sys.exit('[Gentoomuch.pull-stage3] Error code ' + str(code))
# Removing bootstrap image...
code = os.system('docker image rm -f ' + bootstrap_img_name)
if code != 0:
    sys.exit('[Gentoomuch.pull-stage3] Could not remove temporary bootstrap image')
# FINISHED
