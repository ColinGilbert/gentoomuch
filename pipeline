#!/usr/bin/env python3

import sys, os, re

from typing import Dict, List, Set
from include.common import read_file_lines, write_file_lines
from include.prepconfig import ingest_conf

dont_munge = ('bashrc', 'sets', 'modules', 'patches', 'gentoo.conf')

buildmaster               = 'zentoo-builder'
rebuild_emptytree         = 'emerge -uDkq --changed-use --emptytree @'
portage_includes_dir      = './include/portage.defaults'
portage_global_conf_dir   = './config/flags.globals'
portage_local_conf_dir    = './config/flags.locals'

def run_container(root, command):
    return 'docker-compose run ' + root + ' ' + command


# def create_mutable_container(root, name):
     # TODO:
     # Make temp Dockerfile
     # Build our Dockerfile
     # Assign the name

# Ok, this is gonna be fun...
# First (string) key represents the filename
# Second (string) key is the variable/package atom
# Third (bool) key is whether or not the flags (up next) is off or on
# Our flags are held in a list: Depending on whether or not there is a negative sign in-front, a flag is found in a list referenced by the key of True or False. For variables with flags such as -march=..., it will be interpreted as a negative, so you must drain both lists.
def collect_portage_vars(config_dir, portage_environment : Dict[str, Dict[str, Dict[bool, List[str]]]], local_config_name):
    for (dirpath, dirnames, filenames) in os.walk(config_dir):
        print('Walking over ' + dirpath)
        for f in filenames:
            if not f in dont_munge and not dirpath in dont_munge:
                print('Ingesting ' + f)
                lines = read_file_lines(dirpath + '/' + f)
                # We need to strip the global directory information in order to have the (local) config filenames all indexing into their proper key. This means lots of nested regexps. Huh.
                cleaned_filename = re.sub('^/', '', re.sub('^' + local_config_name, '', re.sub('^/', '', re.sub('^' + local_config_name, '', re.sub(portage_local_conf_dir, '', re.sub(portage_global_conf_dir, '', re.sub(portage_includes_dir, '', dirpath + '/' + f)))))))
                if not f == '': # Blank names mess things up.
                    if cleaned_filename in portage_environment:
                        ingest_conf(lines, portage_environment[cleaned_filename], True)
                    else:
                        portage_environment[cleaned_filename] = dict()
                        ingest_conf(lines, portage_environment[cleaned_filename], True)
                        # print('Done ingesting ' + cleaned_filename)


def checkout_config(local_conf):
    # Verify existence of directories
    print('Checking portage includes')
    if not os.path.isdir(portage_includes_dir):
        return False
    print('Checking portage globals')
    if not os.path.isdir(portage_global_conf_dir):
        return False
    print('Checking portage locals')
    if not os.path.isdir(portage_local_conf_dir + '/' + local_conf):
        return False
    print('Setting up work env')
    sync_patches_str = ''
    if os.path.isdir(portage_local_conf_dir + '/patches'):
        sync_patches_str += ' && rsync -aHXqv ' + portage_global_conf_dir + '/patches/* ./work/portage/patches'
    if os.path.isdir(portage_global_conf_dir + '/patches'):
        sync_patches_str += ' && rsync -aHVqv ' + portage_local_conf_dir + '/' + local_conf + '/patches/* ./work/portage/patches'
    code = os.system('rm -rf ./work/portage/* && mkdir -p ./work/portage/sets && mkdir -p ./work/portage/patches && rsync -aHXqv ./config/package.sets/* ./work/portage/sets ' + sync_patches_str)
    if not code == 0:
        return False
    portage_vars = dict()
    collect_portage_vars(portage_includes_dir, portage_vars, local_conf)
    collect_portage_vars(portage_global_conf_dir, portage_vars, local_conf)
    collect_portage_vars(portage_local_conf_dir + '/' + local_conf, portage_vars, local_conf)
    for filepath in portage_vars:
        print('File ' + filepath)
        expanded_filepath = filepath.split('/')
        print(expanded_filepath)
        print('Expanded filepath (list) length = ' + str(len(expanded_filepath)))
        prefix = './work/portage/'
        if len(expanded_filepath) > 1:
            print('Going into deeper waters')
            for p in expanded_filepath[:-1]:
                prefix += p
                prefix += '/'
                print('prefix = ' + prefix)
                if not os.path.isdir(prefix):
                    print('Making directory ' + prefix)
                    os.mkdir(prefix)
        lines = []
        filename = ''
        if len(expanded_filepath) > 1:
            filename = expanded_filepath[-1]
        else:
            filename = filepath
        uses_equals_sign = False
        if filename[-5:] == '.conf':
            uses_equals_sign = True
        for variable in portage_vars[filepath]:
            current_line = variable
            if uses_equals_sign:
                current_line += '= '
            else:
                current_line += ' '
            for flag in portage_vars[filepath][variable][True]:
                current_line += flag
                current_line += ' '
            for flag in portage_vars[filepath][variable][False]:
                current_line += '-'
                current_line += flag
                current_line += ' '
            #if uses_equals_sign:
                # current_line += '"'
            current_line += '\n'
            lines.append(current_line)
        write_file_lines(prefix + filename, lines)
    return True


def build(packageset):
    return 'emerge -uDkq --changed-use @' + packageset


def install(packageset):
    return "FEATURES='usepkgonly' " + build(packageset)


code = checkout_config('zentoo/builder')
if code == False:
    print("Error!")






#TODO: Optimize into a single docker-compose run

# We run the initial bootstrap
#code = os.system("docker-compose down && docker-compose up -d")
#if code != 0:
#    sys.exit("Could not run Docker Compose!")
#code = os.system(checkout_config("bootstrap") + " && " + run_container(buildmaster, "bash -c '" + rebuild_emptytree + "'"))

# We can now recompile libcap with its default options again.
#if code == 0:
#    code = os.system(checkout_config("")  + " && " + run_container(buildmaster, build("zentoo/build-server")))


# Now, we loop over the files defining what we'll build

