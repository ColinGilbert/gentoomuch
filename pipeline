#!/usr/bin/env python3

import sys, os, re
from include.munging import stage3, munger
from include.gentoomuch_common import read_file_lines, write_file_lines, read_by_tokens, output_path, config_dir, stage_defines_path, cpu_path, pkgset_path, local_config_basepath, hooks_path, kernel_path, global_config_path
from typing import Dict, List, Set


builder           = 'zentoo-builder'
rebuild_emptytree = 'emerge -uDkqa --changed-use --emptytree @world'

msg_prefix = '[GentooMuch.pipeline] '

debug = True

def run_container(root, command):
    return 'docker-compose run ' + root + ' ' + command

def build(packageset):
    return 'emerge -uDkq --changed-use @' + packageset

def install(packageset):
    return "FEATURES='usepkgonly' " + build(packageset)




# stage_defines_path          = config_dir + 'stage.defines/'
# cpu_path                    = config_dir + 'cpu.defines/'
# pkgset_path                 = config_dir + 'package.sets/'
# local_config_basepath       = config_dir + 'portage.locals/'
# hooks_path                  = config_dir + 'build.hooks/'
# kernel_path                 = config_dir + 'kernel.defines/'
# global_config_path          = config_dir + 'portage.global/'



class stage_combiner:
    # We run the initial bootstrap.
    def ingest_stage_defines(self, user_stage):
        os.system('rm -rf ./work/portage/*')
        user_stage_path = stage_path + user_stage
        if not os.path.isdir(user_stage_path):
            sys.exit(msg_prefix + 'Could not find stage definitions directory: ' + user_stage_path)
        if os.path.isfile(os.path.join(user_stage_path, 'cpu')):
            cpu_conf = open(os.path.join(user_stage_path, 'cpu')).read().strip()
        else:
            sys.exit(msg_prefix + 'Could not find cpu defines file: ' + os.path.join(user_stage_path, 'cpu'))
        if not os.path.isdir(os.path.join(cpu_path, cpu_conf)):
            sys.exit(msg_prefix + 'CPU config directory: ' + os.path.join(cpu_path, cpu_conf) + ' does not exist.')
        if os.path.isfile(os.path.join(user_stage_path, 'flags')):
            flags_conf = read_file_lines(os.path.join(user_stage_path, 'flags'))
        else:
            sys.exit(msg_prefix + 'flags config directory: ' + os.path.join(user_stage_path, 'flags') + ' does not exist.')
        #if not check_if_portage_sets_present(flags_conf):
        #     sys.exit('Could not find all attached flagsets')
        if os.path.isfile(os.path.join(user_stage_path, '/packages')):
            todo['packages'] = read_file_lines(os.path.join(user_stage_path, '/packages'))
        if os.path.isfile(os.path.join(user_stage_path, '/profiles')):
            todo['profiles'] = read_file_lines(os.path.join(user_stage_path, '/profiles'))
        if os.path.isfile(os.path.join(user_stage_path, '/hooks')):
            todo['hooks'] = read_file_lines(os.path.join(user_stage_path, '/hooks'))

    def checkout_common_config(self, cpu_conf, flags_conf):
        # Verify existence of directories.
        if debug:
            print('Checking Portage globals.')
        if not os.path.isdir(global_flags_path):
            sys.exit('Global (user-defined) Portage/flags config directory at ' + global_flags_path + ' does not exist.')
        if not os.path.exists(output_path):
            os.mkdir(output_path)
        if os.path.isdir(os.path.join(cpu_path, cpu_conf)):
            # Ingest config
            print('Replace me') 
        else:
            sys.exit('CPU config directory at ' + os.path.join(cpu_path, cpu_conf) + ' does not exist.')
        if debug:
            print('Checking for the existence of local flagsets.')
        flagsets_to_add = []
        if len(flags_conf) > 0:
            # Check out what's inside our list of flagset.
            for flg in flags_conf:
                flg = flg.strip()
                if flg == '':
                    continue
                if flg[0] == '@':
                    flg = flg[1:]
                if os.path.isdir(os.path.join(flagset_path, flg)):
                    flagsets_to_add.append(flg)
                else:
                    sys.exit('The user-provided local Portage/flags directory at ' + os.path.join(flagset_path, flg)  + ' does not exist.')
        
        print('Flags config: ' + flags_conf)
        if debug:
            print('Setting up work env.')
        # Here, we deal with the sets and patches directories
        rsync_cmd = 'rsync -aHVXqv'
        sync_sets_str = rsync_cmd + ' ./config/sets/* ' + os.path.join(output_path, 'sets')
        sync_patches_str = rsync_cmd + ' ./config/patches/* ' + os.path.join(output_path, 'patches')
        # We now add package sets. These are universal.
        code = os.system(sync_sets_str + ' && ' + sync_patches_str) 
        if not code == 0:
            sys.exit("stage3_config(): Could not rsync patches, with error code: " + code)

    def __init__(self):
        self.todo = dict() # Dict[str, List[str]]
        self.accum = stage()


# Now, we loop over the file defining what we'll build.
build_list = read_file_lines('./config/stages.build')
accum = stage3()
if not os.path.isdir(output_path):
    os.mkdir(output_path)
code = os.system('rm -rf ./work/portage/*')
accum.ingest('./config/portage.locals/zentoo/test')
#for line in build_list:
#    # Travel to the directory
#    #code = accum.ingest()
#    #if code == False:
#    #    sys.exit("Error! Config failed for " + line)
#    # Rebuild all packages to be made
#    # code = os.system(run_container(builder, rebuild_emptytree))
#    # if code == 0:
#    #    sys.exit('Could not run container build: ' + line)
